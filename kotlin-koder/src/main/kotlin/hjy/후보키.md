# í›„ë³´í‚¤

```js
/**
 * 1. ê²°êµ­ í•µì‹¬ì€ ì¡°í•© ë¬¸ì œ.
 * [a,b,c,d] => [a, b] [a, c] [a, d] [b, c] [b, d] [c, d]
 */
const comb = (arr, count) => {
  if (count === 1) return arr.map((value) => [value]);

  const combinations = [];

  arr.forEach((value, index) => {
    const nextArr = arr.filter((_, nextIndex) => index < nextIndex);
    const result = comb(nextArr, count - 1).map((res) => [value, ...res]);

    combinations.push(...result);
  });

  return combinations;
};

/**
 * ë¡œìš°ë¡œ ë¬¶ì¸ ê°’ì„ ì¹¼ëŸ¼ì— ë”°ë¥¸ ê°’ë“¤ë¡œ ë¬¶ì–´ì„œ ë°˜í™˜í•œë‹¤.
 */
const zip = (...args) => {
  const res = Array.from({ length: args[0].length }, () => []);

  args.forEach((row) => {
    row.forEach((col, colIndex) => {
      res[colIndex].push(col);
    });
  });

  return res;
};

/**
 * ì¶”í›„ í‚¤ ìƒì„±ì— ëŒ€í•œ ìƒì„¸í•œ ê·œì¹™ì´ ìƒê¸´ë‹¤ë©´ ì‰½ê²Œ ë°”ê¿€ ìˆ˜ ìžˆë„ë¡ í•˜ê¸° ìœ„í•œ ì „ëžµ ê°ì²´ ìƒì„±
 */
class AlphabetKeyIndexStrategy {
  constructor(indexCount, caseType = "uppercase") {
    if (indexCount > 26) {
      throw new Error("ì•ŒíŒŒë²³ ìˆ˜ë³´ë‹¤ ë§ŽìŠµë‹ˆë‹¤.");
    }

    this._indexCount = indexCount;
    this._caseType = caseType;
  }

  run() {
    const indices = Array.from({ length: this._indexCount }, (_, i) =>
      String.fromCharCode(65 + i)
    );

    return this._caseType === "uppercase"
      ? indices
      : indices.map((v) => v.toLowerCase());
  }
}

/**
 * í‚¤ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•œ ì±…ìž„ì„ ê°–ëŠ” ê°ì²´ì´ë‹¤.
 * ì•„ì§ ìŠ¤ìœ„ì¹­í•˜ì§€ëŠ” ì•Šê¸° ë•Œë¬¸ì— set í•¨ìˆ˜ëŠ” ë§Œë“¤ì§€ ì•Šì•˜ë‹¤.
 */
class KeyGenerator {
  constructor(num, Strategy = AlphabetKeyIndexStrategy) {
    this._Strategy = new Strategy(num);
  }

  generate() {
    return this._Strategy.run();
  }
}

/**
 * 2. í…Œì´ë¸”ì—ì„œ ëžœë¤í•˜ê²Œ í‚¤ë¥¼ ìƒì„±í•˜ê³ , í‚¤ì™€ í‚¤ì— ëŒ€í•œ ê°’ë“¤ì„ ë§¤í•‘í•´ì•¼ í•œë‹¤.
 */
class Table {
  constructor(rawData, ColumnKeyGenerator = KeyGenerator) {
    this._data = rawData;

    this._ColumnKeyGenerator = new ColumnKeyGenerator(this.colLength);
  }

  get rowLength() {
    return this._data.length;
  }

  get colLength() {
    return this._data?.[0]?.length ?? 0;
  }

  get columnKeys() {
    return this._ColumnKeyGenerator.generate();
  }

  get columns() {
    const dataZip = zip(...this.data);

    return this.columnKeys.reduce(
      (acc, cur, index) => ({
        ...acc,
        [cur]: dataZip[index],
      }),
      {}
    );
  }

  get data() {
    return this._data;
  }
}

/**
 * í˜„ìž¬ ë¶€ë¶„ì§‘í•©ì´ ì¡´ìž¬í•˜ëŠ”ì§€ë¥¼ ì²´í¬ (*ìµœì†Œì„±)
 */
const hasSubset = (setArr, target) => {
  return setArr.every(
    (cmpArr) => !cmpArr.every((value) => target.includes(value))
  );
};

/**
 * í›„ë³´í‚¤ë¡œì„œ ìœ ì¼ì„±ì„ ê°–ê³  ìžˆëŠ”ì§€ í™•ì¸ (*ìœ ì¼ì„±)
 */
const isUnique = (
  columns,
  combination,
  rowLength,
  separator = "ðŸ‘‹ðŸ»ðŸ–ðŸ»ðŸ‘‹ðŸ»ì„¸ìƒì„ë°”ê¾¸ëŠ”ë±…í¬ëª°ðŸ‘‹ðŸ»ðŸ–ðŸ»ðŸ‘‹ðŸ»"
) => {
  const res = Array.from({ length: rowLength }, () => []);

  for (let i = 0; i < rowLength; i += 1) {
    combination.forEach((key) => {
      res[i].push(columns[key][i]);
    });
  }

  return new Set(res.map((v) => v.join(separator))).size === rowLength;
};

const getAllCandidateKeys = (table) => {
  const result = new Set();

  for (let keyCount = 1; keyCount <= table.colLength; keyCount += 1) {
    const combinations = comb(table.columnKeys, keyCount);

    combinations.forEach((combination) => {
      const resultArr = [...result];

      if (
        /**
         * ê³„ì†í•´ì„œ Nê°œë¥¼ ë½‘ì•„ë‚´ë©´ì„œ ì¡°í•©ì´ ìµœì†Œë‹¨ìœ„ë¡œ ìœ íš¨í•œì§€ë¥¼ íŒë³„í•œë‹¤. ì´ëŠ” ìµœì†Œì„±ì„ ë§Œì¡±í•œë‹¤.
         */
        hasSubset(resultArr, combination) &&
        /**
         * ì´ë•Œ, í˜„ìž¬ í›„ë³´í‚¤ë§Œìœ¼ë¡œ ë§Œë“¤ì–´ì§„ rowì˜ ê°’ì´ ìœ ì¼í•œì§€ íŒë³„í•œë‹¤. ì´ëŠ” ìœ ì¼ì„±ì„ ë§Œì¡±í•œë‹¤.
         */
        isUnique(table.columns, combination, table.rowLength)
      ) {
        /**
         * ê²°ê³¼ì ìœ¼ë¡œ ì´ 2ê°€ì§€ë¥¼ ë§Œì¡±í•˜ë©´ í‚¤ë¥¼ ë“±ë¡í•œë‹¤.
         */
        result.add(combination);
      }
    });
  }

  /**
   * ëª¨ë“  ë°˜ë³µë¬¸ì„ ëŒë¦° í›„ ê²°ê³¼ë¥¼ ë°˜í•œí™˜ë‹¤.
   */
  return [...result];
};

const solution = (relations) => {
  const table = new Table(relations);

  return getAllCandidateKeys(table).length;
};

console.log(
  solution([
    ["100", "ryan", "music", "2"],
    ["200", "apeach", "math", "2"],
    ["300", "tube", "computer", "3"],
    ["400", "con", "computer", "4"],
    ["500", "muzi", "music", "3"],
    ["600", "apeach", "music", "2"],
  ])
);
```
